--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;

SET search_path = public, pg_catalog;

--
-- Data for Name: db_types; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY db_types (id, full_name, simple_name, setup_script_template, jdbc_class_name, drop_script_template, custom_jdbc_attributes, batch_separator, notes, sample_fragment, execution_plan_prefix, execution_plan_suffix, execution_plan_xslt, context, execution_plan_check, is_latest_stable, list_database_script) FROM stdin;
4	Oracle 11g R2	Oracle	\ncreate user user_#databaseName# identified by "#databaseName#" default tablespace fiddledata profile fiddleusers\n/\ngrant create session, create synonym, create table, create type, create view, create materialized view, create procedure, create sequence, create trigger to user_#databaseName#\n/\nalter user user_#databaseName# quota 5M on fiddledata\n/\ncreate table system.deferred_#databaseName# (val NUMBER(1) CONSTRAINT deferred_#databaseName#_ck CHECK(val =1) DEFERRABLE INITIALLY DEFERRED)\n/\ngrant insert on system.deferred_#databaseName# to user_#databaseName#\n/\n	oracle.jdbc.OracleDriver	DECLARE\n  l_cnt integer;\nBEGIN\n  EXECUTE IMMEDIATE 'alter user user_#databaseName# account lock';\n  FOR x IN (SELECT *\n              FROM v$session\n             WHERE username = 'USER_#databaseName#')\n  LOOP\n    EXECUTE IMMEDIATE 'alter system disconnect session ''' || x.sid || ',' || x.serial# || ''' IMMEDIATE';\n  END LOOP;\n\n  -- Wait for as long as it takes for all the sessions to go away\n  LOOP\n    SELECT COUNT(*)\n      INTO l_cnt\n      FROM v$session\n     WHERE username = 'USER_#databaseName#';\n    EXIT WHEN l_cnt = 0;\n    dbms_lock.sleep( 1 );\n  END LOOP;\n\n FOR cc IN (SELECT owner, table_name FROM all_tables WHERE tablespace_name = upper('fiddledata') AND table_lock = 'DISABLED' and owner = upper('user_#databaseName#')) LOOP\n  EXECUTE IMMEDIATE 'ALTER TABLE "' || cc.owner || '"."' || cc.table_name || '" ENABLE TABLE LOCK';\nEND LOOP;  EXECUTE IMMEDIATE 'drop user user_#databaseName# cascade';\n\n  EXECUTE IMMEDIATE 'drop table system.deferred_#databaseName#';\nEND;	\N	/	Oracle does not support multiple statements in batch.  Separate each statement with a line consisting of a single /, and do not terminate statements with semicolons.	4/c0be1/1	\n\texplain plan set STATEMENT_ID = '#schema_short_code#/#query_id#' for \n	\n\n\n/\n\nselect '<pre>' || dbms_xplan.display_plan(format=>'ALL', statement_id => '#schema_short_code#/#query_id#') || '</pre>' as XPLAN FROM dual	\N	host	\N	1	select schema_name from (select distinct lower(replace(USERNAME, 'USER', 'DB')) as schema_name from all_users) tmp
6	MS SQL Server 2014	SQL Server	\nCREATE DATABASE db_#databaseName#;\nGO\n\nUSE db_#databaseName#;\nGO\n\nCREATE LOGIN user_#databaseName#\nWITH PASSWORD = '#databaseName#';\nGO\n\nCREATE USER user_#databaseName#;\nGO\n\nGRANT \nCREATE TABLE,\nCREATE TYPE,\nCREATE VIEW,\nCREATE PROCEDURE,\nCREATE FUNCTION,\nCREATE FULLTEXT CATALOG,\nEXECUTE,\nDELETE,\nINSERT,\nREFERENCES,\nSELECT,\nSHOWPLAN,\nUPDATE\nTO user_#databaseName#;\nGO\n\n\n\nALTER LOGIN user_#databaseName# WITH DEFAULT_DATABASE=db_#databaseName#;\nGO\n\nGRANT ALTER ON SCHEMA::dbo TO user_#databaseName#;\nGO\n\nuse master;\n\n	net.sourceforge.jtds.jdbc.Driver	exec dbo.clearDBUsers 'db_#databaseName#';\nGO\ndrop database db_#databaseName#;\nGO\ndrop login user_#databaseName#;\n	\N	GO	\N	6/a7540/1	\nSET SHOWPLAN_XML ON;\nGO\n	\nGO\nSET SHOWPLAN_XML OFF	<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n  xmlns:msxsl="urn:schemas-microsoft-com:xslt"\n  xmlns:s="http://schemas.microsoft.com/sqlserver/2004/07/showplan"\n  exclude-result-prefixes="msxsl s xsl">\n  <xsl:output method="html" indent="no" omit-xml-declaration="yes" />\n\n  <!-- Disable built-in recursive processing templates -->\n  <xsl:template match="*|/|text()|@*" mode="NodeLabel2" />\n  <xsl:template match="*|/|text()|@*" mode="ToolTipDescription" />\n  <xsl:template match="*|/|text()|@*" mode="ToolTipDetails" />\n\n  <!-- Default template -->\n  <xsl:template match="/">\n    <xsl:apply-templates select="s:ShowPlanXML" />\n  </xsl:template>\n\n  <!-- Outermost div that contains all statement plans. -->\n  <xsl:template match="s:ShowPlanXML">\n    <div class="qp-root">\n      <xsl:apply-templates select="s:BatchSequence/s:Batch/s:Statements/s:StmtSimple" />  \n    </div>\n  </xsl:template>\n  \n  <!-- Matches a branch in the query plan (either an operation or a statement) -->\n  <xsl:template match="s:RelOp|s:StmtSimple">\n    <div class="qp-tr">\n      <div>\n        <div class="qp-node">\n          <xsl:apply-templates select="." mode="NodeIcon" />\n          <xsl:apply-templates select="." mode="NodeLabel" />\n          <xsl:apply-templates select="." mode="NodeLabel2" />\n          <xsl:apply-templates select="." mode="NodeCostLabel" />\n          <xsl:call-template name="ToolTip" />\n        </div>\n      </div>\n      <div><xsl:apply-templates select="*/s:RelOp" /></div>\n    </div>\n  </xsl:template>\n\n  <!-- Writes the tool tip -->\n  <xsl:template name="ToolTip">\n    <div class="qp-tt">\n      <div class="qp-tt-header"><xsl:value-of select="@PhysicalOp | @StatementType" /></div>\n      <div><xsl:apply-templates select="." mode="ToolTipDescription" /></div>\n      <xsl:call-template name="ToolTipGrid" />\n      <xsl:apply-templates select="* | @* | */* | */@*" mode="ToolTipDetails" />\n    </div>\n  </xsl:template>\n\n  <!-- Writes the grid of node properties to the tool tip -->\n  <xsl:template name="ToolTipGrid">\n    <table>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="s:QueryPlan/@CachedPlanSize" />\n        <xsl:with-param name="Label">Cached plan size</xsl:with-param>\n        <xsl:with-param name="Value" select="concat(s:QueryPlan/@CachedPlanSize, ' B')" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Physical Operation</xsl:with-param>\n        <xsl:with-param name="Value" select="@PhysicalOp" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Logical Operation</xsl:with-param>\n        <xsl:with-param name="Value" select="@LogicalOp" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Actual Number of Rows</xsl:with-param>\n        <xsl:with-param name="Value" select="s:RunTimeInformation/s:RunTimeCountersPerThread/@ActualRows" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateIO" />\n        <xsl:with-param name="Label">Estimated I/O Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@EstimateIO" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateCPU" />\n        <xsl:with-param name="Label">Estimated CPU Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@EstimateCPU" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <!-- TODO: Estimated Number of Executions -->\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Number of Executions</xsl:with-param>\n        <xsl:with-param name="Value" select="s:RunTimeInformation/s:RunTimeCountersPerThread/@ActualExecutions" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Degree of Parallelism</xsl:with-param>\n        <xsl:with-param name="Value" select="s:QueryPlan/@DegreeOfParallelism" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Memory Grant</xsl:with-param>\n        <xsl:with-param name="Value" select="s:QueryPlan/@MemoryGrant" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateIO | @EstimateCPU" />\n        <xsl:with-param name="Label">Estimated Operator Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:variable name="EstimatedOperatorCost">\n            <xsl:call-template name="EstimatedOperatorCost" />\n          </xsl:variable>\n          <xsl:variable name="TotalCost">\n            <xsl:value-of select="ancestor::s:StmtSimple/@StatementSubTreeCost" />\n          </xsl:variable>\n          \n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="$EstimatedOperatorCost" />\n          </xsl:call-template>\n          (<xsl:value-of select="format-number(number($EstimatedOperatorCost) div number($TotalCost), '0%')" />)\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@StatementSubTreeCost | @EstimatedTotalSubtreeCost" />\n        <xsl:with-param name="Label">Estimated Subtree Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@StatementSubTreeCost | @EstimatedTotalSubtreeCost" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Estimated Number of Rows</xsl:with-param>\n        <xsl:with-param name="Value" select="@StatementEstRows | @EstimateRows" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@AvgRowSize" />\n        <xsl:with-param name="Label">Estimated Row Size</xsl:with-param>\n        <xsl:with-param name="Value" select="concat(@AvgRowSize, ' B')" />\n      </xsl:call-template>\n      <!-- TODO: Actual Rebinds\n           TODO: Actual Rewinds -->\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="s:IndexScan/@Ordered" />\n        <xsl:with-param name="Label">Ordered</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:choose>\n            <xsl:when test="s:IndexScan/@Ordered = 1">True</xsl:when>\n            <xsl:otherwise>False</xsl:otherwise>\n          </xsl:choose>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Node ID</xsl:with-param>\n        <xsl:with-param name="Value" select="@NodeId" />\n      </xsl:call-template>\n    </table>\n  </xsl:template>\n\n  <!-- Calculates the estimated operator cost. -->\n  <xsl:template name="EstimatedOperatorCost">\n    <xsl:variable name="EstimateIO">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="@EstimateIO" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name="EstimateCPU">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="@EstimateCPU" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:value-of select="number($EstimateIO) + number($EstimateCPU)" />\n  </xsl:template>\n\n  <!-- Renders a row in the tool tip details table. -->\n  <xsl:template name="ToolTipRow">\n    <xsl:param name="Label" />\n    <xsl:param name="Value" />\n    <xsl:param name="Condition" select="$Value" />\n    <xsl:if test="$Condition">\n      <tr>\n        <th><xsl:value-of select="$Label" /></th>\n        <td><xsl:value-of select="$Value" /></td>\n      </tr>      \n    </xsl:if>\n  </xsl:template>\n\n  <!-- Prints the name of an object. -->\n  <xsl:template match="s:Object | s:ColumnReference" mode="ObjectName">\n    <xsl:param name="ExcludeDatabaseName" select="false()" />\n    <xsl:choose>\n      <xsl:when test="$ExcludeDatabaseName">\n        <xsl:for-each select="@Table | @Index | @Column | @Alias">\n          <xsl:value-of select="." />\n          <xsl:if test="position() != last()">.</xsl:if>\n        </xsl:for-each>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:for-each select="@Database | @Schema | @Table | @Index | @Column | @Alias">\n          <xsl:value-of select="." />\n          <xsl:if test="position() != last()">.</xsl:if>\n        </xsl:for-each>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Displays the node cost label. -->\n  <xsl:template match="s:RelOp" mode="NodeCostLabel">\n    <xsl:variable name="EstimatedOperatorCost"><xsl:call-template name="EstimatedOperatorCost" /></xsl:variable>\n    <xsl:variable name="TotalCost"><xsl:value-of select="ancestor::s:StmtSimple/@StatementSubTreeCost" /></xsl:variable>\n    <div>Cost: <xsl:value-of select="format-number(number($EstimatedOperatorCost) div number($TotalCost), '0%')" /></div>\n  </xsl:template>\n\n  <!-- Dont show the node cost for statements. -->\n  <xsl:template match="s:StmtSimple" mode="NodeCostLabel" />\n\n  <!-- \n  ================================\n  Tool tip detail sections\n  ================================\n  The following section contains templates used for writing the detail sections at the bottom of the tool tip,\n  for example listing outputs, or information about the object to which an operator applies.\n  -->\n\n  <xsl:template match="*/s:Object" mode="ToolTipDetails">\n    <!-- TODO: Make sure this works all the time -->\n    <div class="qp-bold">Object</div>\n    <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:SetPredicate[s:ScalarOperator/@ScalarString]" mode="ToolTipDetails">\n    <div class="qp-bold">Predicate</div>\n    <div><xsl:value-of select="s:ScalarOperator/@ScalarString" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:OutputList[count(s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Output List</div>\n    <xsl:for-each select="s:ColumnReference">\n      <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <xsl:template match="s:NestedLoops/s:OuterReferences[count(s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Outer References</div>\n    <xsl:for-each select="s:ColumnReference">\n      <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <xsl:template match="@StatementText" mode="ToolTipDetails">\n    <div class="qp-bold">Statement</div>\n    <div><xsl:value-of select="." /></div>\n  </xsl:template>\n\n  <xsl:template match="s:Sort/s:OrderBy[count(s:OrderByColumn/s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Order By</div>\n    <xsl:for-each select="s:OrderByColumn">\n      <div>\n        <xsl:apply-templates select="s:ColumnReference" mode="ObjectName" />\n        <xsl:choose>\n          <xsl:when test="@Ascending = 1"> Ascending</xsl:when>\n          <xsl:otherwise> Descending</xsl:otherwise>\n        </xsl:choose>\n      </div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <!-- TODO: Seek Predicates -->\n\n  <!-- \n  ================================\n  Node icons\n  ================================\n  The following templates determine what icon should be shown for a given node\n  -->\n\n  <!-- Use the logical operation to determine the icon for the "Parallelism" operators. -->\n  <xsl:template match="s:RelOp[@PhysicalOp = 'Parallelism']" mode="NodeIcon" priority="1">\n    <xsl:element name="div">\n      <xsl:attribute name="class">qp-icon-<xsl:value-of select="translate(@LogicalOp, ' ', '')" /></xsl:attribute>\n    </xsl:element>\n  </xsl:template>\n\n  <!-- Use the physical operation to determine icon if it is present. -->\n  <xsl:template match="*[@PhysicalOp]" mode="NodeIcon">\n    <xsl:element name="div">\n      <xsl:attribute name="class">qp-icon-<xsl:value-of select="translate(@PhysicalOp, ' ', '')" /></xsl:attribute>\n    </xsl:element>\n  </xsl:template>\n  \n  <!-- Matches all statements. -->\n  <xsl:template match="s:StmtSimple" mode="NodeIcon">\n    <div class="qp-icon-Statement"></div>\n  </xsl:template>\n\n  <!-- Fallback template - show the Bitmap icon. -->\n  <xsl:template match="*" mode="NodeIcon">\n    <div class="qp-icon-Catchall"></div>\n  </xsl:template>\n\n  <!-- \n  ================================\n  Node labels\n  ================================\n  The following section contains templates used to determine the first (main) label for a node.\n  -->\n\n  <xsl:template match="s:RelOp" mode="NodeLabel">\n    <div><xsl:value-of select="@PhysicalOp" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:StmtSimple" mode="NodeLabel">\n    <div><xsl:value-of select="@StatementType" /></div>\n  </xsl:template>\n\n  <!--\n  ================================\n  Node alternate labels\n  ================================\n  The following section contains templates used to determine the second label to be displayed for a node.\n  -->\n\n  <!-- Display the object for any node that has one -->\n  <xsl:template match="*[*/s:Object]" mode="NodeLabel2">\n    <xsl:variable name="ObjectName">\n      <xsl:apply-templates select="*/s:Object" mode="ObjectName">\n        <xsl:with-param name="ExcludeDatabaseName" select="true()" />\n      </xsl:apply-templates>\n    </xsl:variable>\n    <div>\n      <xsl:value-of select="substring($ObjectName, 0, 36)" />\n      <xsl:if test="string-length($ObjectName) >= 36">…</xsl:if>\n    </div>\n  </xsl:template>\n\n  <!-- Display the logical operation for any node where it is not the same as the physical operation. -->\n  <xsl:template match="s:RelOp[@LogicalOp != @PhysicalOp]" mode="NodeLabel2">\n    <div>(<xsl:value-of select="@LogicalOp" />)</div>\n  </xsl:template>\n\n  <!-- Disable the default template -->\n  <xsl:template match="*" mode="NodeLabel2" />\n\n  <!-- \n  ================================\n  Tool tip descriptions\n  ================================\n  The following section contains templates used for writing the description shown in the tool tip.\n  -->\n\n  <xsl:template match="*[@PhysicalOp = 'Table Insert']" mode="ToolTipDescription">Insert input rows into the table specified in Argument field.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Compute Scalar']" mode="ToolTipDescription">Compute new values from existing values in a row.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Sort']" mode="ToolTipDescription">Sort the input.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Clustered Index Scan']" mode="ToolTipDescription">Scanning a clustered index, entirely or only a range.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Stream Aggregate']" mode="ToolTipDescription">Compute summary values for groups of rows in a suitably sorted stream.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Hash Match']" mode="ToolTipDescription">Use each row from the top input to build a hash table, and each row from the bottom input to probe into the hash table, outputting all matching rows.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Bitmap']" mode="ToolTipDescription">Bitmap.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Clustered Index Seek']" mode="ToolTipDescription">Scanning a particular range of rows from a clustered index.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Index Seek']" mode="ToolTipDescription">Scan a particular range of rows from a nonclustered index.</xsl:template>\n\n  <xsl:template match="*[@PhysicalOp = 'Parallelism' and @LogicalOp='Repartition Streams']" mode="ToolTipDescription">Repartition Streams.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Parallelism']" mode="ToolTipDescription">An operation involving parallelism.</xsl:template>\n  \n  <xsl:template match="*[s:TableScan]" mode="ToolTipDescription">Scan rows from a table.</xsl:template>\n  <xsl:template match="*[s:NestedLoops]" mode="ToolTipDescription">For each row in the top (outer) input, scan the bottom (inner) input, and output matching rows.</xsl:template>\n  <xsl:template match="*[s:Top]" mode="ToolTipDescription">Select the first few rows based on a sort order.</xsl:template>\n\n  <!-- \n  ================================\n  Number handling\n  ================================\n  The following section contains templates used for handling numbers (scientific notation, rounding etc...)\n  -->\n\n  <!-- Outputs a number rounded to 7 decimal places - to be used for displaying all numbers.\n  This template accepts numbers in scientific notation. -->\n  <xsl:template name="round">\n    <xsl:param name="value" select="0" />\n    <xsl:variable name="number">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="$value" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:value-of select="round(number($number) * 10000000) div 10000000" />\n  </xsl:template>\n  \n  <!-- Template for handling of scientific numbers\n  See: http://www.orm-designer.com/article/xslt-convert-scientific-notation-to-decimal-number -->\n  <xsl:variable name="max-exp">\n    <xsl:value-of select="'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'" />\n  </xsl:variable>\n\n  <xsl:template name="convertSciToNumString">\n    <xsl:param name="inputVal" select="0" />\n\n    <xsl:variable name="numInput">\n      <xsl:value-of select="translate(string($inputVal),'e','E')" />\n    </xsl:variable>\n\n    <xsl:choose>\n      <xsl:when test="number($numInput) = $numInput">\n        <xsl:value-of select="$numInput" />\n      </xsl:when> \n      <xsl:otherwise>\n        <!-- ==== Mantisa ==== -->\n        <xsl:variable name="numMantisa">\n          <xsl:value-of select="number(substring-before($numInput,'E'))" />\n        </xsl:variable>\n\n        <!-- ==== Exponent ==== -->\n        <xsl:variable name="numExponent">\n          <xsl:choose>\n            <xsl:when test="contains($numInput,'E+')">\n              <xsl:value-of select="substring-after($numInput,'E+')" />\n            </xsl:when>\n            <xsl:otherwise>\n              <xsl:value-of select="substring-after($numInput,'E')" />\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n\n        <!-- ==== Coefficient ==== -->\n        <xsl:variable name="numCoefficient">\n          <xsl:choose>\n            <xsl:when test="$numExponent > 0">\n              <xsl:text>1</xsl:text>\n              <xsl:value-of select="substring($max-exp, 1, number($numExponent))" />\n            </xsl:when>\n            <xsl:when test="$numExponent &lt; 0">\n              <xsl:text>0.</xsl:text>\n              <xsl:value-of select="substring($max-exp, 1, -number($numExponent)-1)" />\n              <xsl:text>1</xsl:text>\n            </xsl:when>\n            <xsl:otherwise>1</xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n        <xsl:value-of select="number($numCoefficient) * number($numMantisa)" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n</xsl:stylesheet>\n	host	//*[@StatementType="COMMIT TRANSACTION"]	1	SELECT schema_name FROM (SELECT name as [schema_name] FROM master..sysdatabases) tmp
7	SQLite (WebSQL)	SQLite	\N	websql	\N	\N	\N	\N	7/44b90/1	\N	\N	\N	browser	\N	1	\N
5	SQLite (SQL.js)	SQLite	\nCREATE USER user_#databaseName# PASSWORD '#databaseName#'	sqljs	\N	\N	\N	\N	5/b5362/1	\N	\N	\N	browser	\N	1	\N
9	MySQL 5.6	MySQL	\nCREATE database db_#databaseName#  default CHARACTER SET = utf8 default COLLATE = utf8_general_ci;\nGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,CREATE TEMPORARY TABLES,CREATE VIEW,SHOW VIEW,ALTER ROUTINE,CREATE ROUTINE,TRIGGER,EXECUTE\n ON db_#databaseName#.* TO user_#databaseName#@'%' IDENTIFIED BY '#databaseName#';\nGRANT SELECT ON performance_schema.* TO user_#databaseName#@'%';\n	org.gjt.mm.mysql.Driver	\n DROP DATABASE db_#databaseName#; drop user user_#databaseName#@'%';\n	\N	\N	\N	9/dcb16/1	explain extended 	\N	\N	host	\N	1	show databases
15	PostgreSQL 9.3	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1 user=postgres');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE upper(pg_stat_activity.datname) = upper('DB_#databaseName#'); DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;	\N	\N	\N	15/35773/1	explain 	\N	\N	host	\N	1	select schema_name from (select datname as schema_name from pg_database) t
1	PostgreSQL 9.1	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.procpid)                                     FROM pg_stat_activity                                                                                                                             WHERE upper(pg_stat_activity.datname) = 'DB_#databaseName#';                                                                                            DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;	\N	\N	Separate multiple statements in PostgreSQL by terminating each one with a semicolon.	1/6ccc5/2	explain 	\N	\N	host	\N	0	select schema_name from (select datname as schema_name from pg_database) t
2	MySQL 5.5	MySQL	\nCREATE database db_#databaseName#  default CHARACTER SET = utf8 default COLLATE = utf8_general_ci;\nGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,CREATE TEMPORARY TABLES,CREATE VIEW,SHOW VIEW,ALTER ROUTINE,CREATE ROUTINE,TRIGGER,EXECUTE\n ON db_#databaseName#.* TO user_#databaseName#@'%' IDENTIFIED BY '#databaseName#';\n	org.gjt.mm.mysql.Driver	\n DROP DATABASE db_#databaseName#; drop user user_#databaseName#@'%';\n	allowMultiQueries=true	\N	Separate multiple statements in MySQL by terminating each one with a semicolon.	2/dcb16/1	explain extended 	\N	\N	host	\N	0	show databases
8	MySQL 5.1	MySQL	\nCREATE database db_#databaseName#  default CHARACTER SET = utf8 default COLLATE = utf8_general_ci;\nGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,CREATE TEMPORARY TABLES,CREATE VIEW,SHOW VIEW,ALTER ROUTINE,CREATE ROUTINE,TRIGGER,EXECUTE\n ON db_#databaseName#.* TO user_#databaseName#@'%' IDENTIFIED BY '#databaseName#';\n	org.gjt.mm.mysql.Driver	\n DROP DATABASE db_#databaseName#; drop user user_#databaseName#@'%';\n	\N	\N	\N	8/a2581/1	explain extended 	\N	\N	host	\N	0	show databases
11	PostgreSQL 8.4	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.procpid)                                     FROM pg_stat_activity                                                                                                                             WHERE upper(pg_stat_activity.datname) = 'DB_#databaseName#';                                                                                            DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;	\N	\N	\N	11/6d80e/1	explain 	\N	\N	host	\N	0	select schema_name from (select datname as schema_name from pg_database) t
12	PostgreSQL 9.2	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.pid)                                     FROM pg_stat_activity                                                                                                                             WHERE upper(pg_stat_activity.datname) = 'DB_#databaseName#';                                                                                            DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;\n\t	\N	\N	\N	12/6d80e/1	explain 	\N	\N	host	\N	0	select schema_name from (select datname as schema_name from pg_database) t
13	MySQL 5.7	MySQL	\nCREATE database db_#databaseName#  default CHARACTER SET = utf8 default COLLATE = utf8_general_ci;\nGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX,CREATE TEMPORARY TABLES,CREATE VIEW,SHOW VIEW,ALTER ROUTINE,CREATE ROUTINE,TRIGGER,EXECUTE\n ON db_#databaseName#.* TO user_#databaseName#@'%' IDENTIFIED BY '#databaseName#';\n	org.gjt.mm.mysql.Driver	\n DROP DATABASE db_#databaseName#; drop user user_#databaseName#@'%';\n	allowMultiQueries=true	\N	Separate multiple statements in MySQL by terminating each one with a semicolon.	2/a2581/1	explain extended 	\N	\N	host	\N	0	show databases
3	MS SQL Server 2008	SQL Server	\nCREATE DATABASE db_#databaseName#;\nGO\nALTER DATABASE db_#databaseName# SET COMPATIBILITY_LEVEL = 100;\nGO\n\nUSE db_#databaseName#;\nGO\n\nCREATE LOGIN user_#databaseName#\nWITH PASSWORD = '#databaseName#';\nGO\n\nCREATE USER user_#databaseName#;\nGO\n\nGRANT \nCREATE TABLE,\nCREATE TYPE,\nCREATE VIEW,\nCREATE PROCEDURE,\nCREATE FUNCTION,\nCREATE FULLTEXT CATALOG,\nEXECUTE,\nDELETE,\nINSERT,\nREFERENCES,\nSELECT,\nSHOWPLAN,\nUPDATE\nTO user_#databaseName#;\nGO\n\n\n\nALTER LOGIN user_#databaseName# WITH DEFAULT_DATABASE=db_#databaseName#;\nGO\n\nGRANT ALTER ON SCHEMA::dbo TO user_#databaseName#;\nGO\n\nuse master;\n\n	net.sourceforge.jtds.jdbc.Driver	exec dbo.clearDBUsers 'db_#databaseName#';\nGO\ndrop database db_#databaseName#;\nGO\ndrop login user_#databaseName#;\n	\N	GO	SQL Server supports multiple statements in a batch separated by semicolons. Separate statement batches with a line consisting of a single GO command, as needed.	3/1fa93/1	\nSET SHOWPLAN_XML ON;\nGO\n	\nGO\nSET SHOWPLAN_XML OFF	\n<?xml version="1.0" encoding="utf-8"?>\n<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"\n  xmlns:msxsl="urn:schemas-microsoft-com:xslt"\n  xmlns:s="http://schemas.microsoft.com/sqlserver/2004/07/showplan"\n  exclude-result-prefixes="msxsl s xsl">\n  <xsl:output method="html" indent="no" omit-xml-declaration="yes" />\n\n  <!-- Disable built-in recursive processing templates -->\n  <xsl:template match="*|/|text()|@*" mode="NodeLabel2" />\n  <xsl:template match="*|/|text()|@*" mode="ToolTipDescription" />\n  <xsl:template match="*|/|text()|@*" mode="ToolTipDetails" />\n\n  <!-- Default template -->\n  <xsl:template match="/">\n    <xsl:apply-templates select="s:ShowPlanXML" />\n  </xsl:template>\n\n  <!-- Outermost div that contains all statement plans. -->\n  <xsl:template match="s:ShowPlanXML">\n    <div class="qp-root">\n      <xsl:apply-templates select="s:BatchSequence/s:Batch/s:Statements/s:StmtSimple" />  \n    </div>\n  </xsl:template>\n  \n  <!-- Matches a branch in the query plan (either an operation or a statement) -->\n  <xsl:template match="s:RelOp|s:StmtSimple">\n    <div class="qp-tr">\n      <div>\n        <div class="qp-node">\n          <xsl:apply-templates select="." mode="NodeIcon" />\n          <xsl:apply-templates select="." mode="NodeLabel" />\n          <xsl:apply-templates select="." mode="NodeLabel2" />\n          <xsl:apply-templates select="." mode="NodeCostLabel" />\n          <xsl:call-template name="ToolTip" />\n        </div>\n      </div>\n      <div><xsl:apply-templates select="*/s:RelOp" /></div>\n    </div>\n  </xsl:template>\n\n  <!-- Writes the tool tip -->\n  <xsl:template name="ToolTip">\n    <div class="qp-tt">\n      <div class="qp-tt-header"><xsl:value-of select="@PhysicalOp | @StatementType" /></div>\n      <div><xsl:apply-templates select="." mode="ToolTipDescription" /></div>\n      <xsl:call-template name="ToolTipGrid" />\n      <xsl:apply-templates select="* | @* | */* | */@*" mode="ToolTipDetails" />\n    </div>\n  </xsl:template>\n\n  <!-- Writes the grid of node properties to the tool tip -->\n  <xsl:template name="ToolTipGrid">\n    <table>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="s:QueryPlan/@CachedPlanSize" />\n        <xsl:with-param name="Label">Cached plan size</xsl:with-param>\n        <xsl:with-param name="Value" select="concat(s:QueryPlan/@CachedPlanSize, ' B')" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Physical Operation</xsl:with-param>\n        <xsl:with-param name="Value" select="@PhysicalOp" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Logical Operation</xsl:with-param>\n        <xsl:with-param name="Value" select="@LogicalOp" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Actual Number of Rows</xsl:with-param>\n        <xsl:with-param name="Value" select="s:RunTimeInformation/s:RunTimeCountersPerThread/@ActualRows" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateIO" />\n        <xsl:with-param name="Label">Estimated I/O Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@EstimateIO" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateCPU" />\n        <xsl:with-param name="Label">Estimated CPU Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@EstimateCPU" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <!-- TODO: Estimated Number of Executions -->\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Number of Executions</xsl:with-param>\n        <xsl:with-param name="Value" select="s:RunTimeInformation/s:RunTimeCountersPerThread/@ActualExecutions" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Degree of Parallelism</xsl:with-param>\n        <xsl:with-param name="Value" select="s:QueryPlan/@DegreeOfParallelism" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Memory Grant</xsl:with-param>\n        <xsl:with-param name="Value" select="s:QueryPlan/@MemoryGrant" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@EstimateIO | @EstimateCPU" />\n        <xsl:with-param name="Label">Estimated Operator Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:variable name="EstimatedOperatorCost">\n            <xsl:call-template name="EstimatedOperatorCost" />\n          </xsl:variable>\n          <xsl:variable name="TotalCost">\n            <xsl:value-of select="ancestor::s:StmtSimple/@StatementSubTreeCost" />\n          </xsl:variable>\n          \n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="$EstimatedOperatorCost" />\n          </xsl:call-template>\n          (<xsl:value-of select="format-number(number($EstimatedOperatorCost) div number($TotalCost), '0%')" />)\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@StatementSubTreeCost | @EstimatedTotalSubtreeCost" />\n        <xsl:with-param name="Label">Estimated Subtree Cost</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:call-template name="round">\n            <xsl:with-param name="value" select="@StatementSubTreeCost | @EstimatedTotalSubtreeCost" />\n          </xsl:call-template>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Estimated Number of Rows</xsl:with-param>\n        <xsl:with-param name="Value" select="@StatementEstRows | @EstimateRows" />\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="@AvgRowSize" />\n        <xsl:with-param name="Label">Estimated Row Size</xsl:with-param>\n        <xsl:with-param name="Value" select="concat(@AvgRowSize, ' B')" />\n      </xsl:call-template>\n      <!-- TODO: Actual Rebinds\n           TODO: Actual Rewinds -->\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Condition" select="s:IndexScan/@Ordered" />\n        <xsl:with-param name="Label">Ordered</xsl:with-param>\n        <xsl:with-param name="Value">\n          <xsl:choose>\n            <xsl:when test="s:IndexScan/@Ordered = 1">True</xsl:when>\n            <xsl:otherwise>False</xsl:otherwise>\n          </xsl:choose>\n        </xsl:with-param>\n      </xsl:call-template>\n      <xsl:call-template name="ToolTipRow">\n        <xsl:with-param name="Label">Node ID</xsl:with-param>\n        <xsl:with-param name="Value" select="@NodeId" />\n      </xsl:call-template>\n    </table>\n  </xsl:template>\n\n  <!-- Calculates the estimated operator cost. -->\n  <xsl:template name="EstimatedOperatorCost">\n    <xsl:variable name="EstimateIO">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="@EstimateIO" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name="EstimateCPU">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="@EstimateCPU" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:value-of select="number($EstimateIO) + number($EstimateCPU)" />\n  </xsl:template>\n\n  <!-- Renders a row in the tool tip details table. -->\n  <xsl:template name="ToolTipRow">\n    <xsl:param name="Label" />\n    <xsl:param name="Value" />\n    <xsl:param name="Condition" select="$Value" />\n    <xsl:if test="$Condition">\n      <tr>\n        <th><xsl:value-of select="$Label" /></th>\n        <td><xsl:value-of select="$Value" /></td>\n      </tr>      \n    </xsl:if>\n  </xsl:template>\n\n  <!-- Prints the name of an object. -->\n  <xsl:template match="s:Object | s:ColumnReference" mode="ObjectName">\n    <xsl:param name="ExcludeDatabaseName" select="false()" />\n    <xsl:choose>\n      <xsl:when test="$ExcludeDatabaseName">\n        <xsl:for-each select="@Table | @Index | @Column | @Alias">\n          <xsl:value-of select="." />\n          <xsl:if test="position() != last()">.</xsl:if>\n        </xsl:for-each>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:for-each select="@Database | @Schema | @Table | @Index | @Column | @Alias">\n          <xsl:value-of select="." />\n          <xsl:if test="position() != last()">.</xsl:if>\n        </xsl:for-each>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Displays the node cost label. -->\n  <xsl:template match="s:RelOp" mode="NodeCostLabel">\n    <xsl:variable name="EstimatedOperatorCost"><xsl:call-template name="EstimatedOperatorCost" /></xsl:variable>\n    <xsl:variable name="TotalCost"><xsl:value-of select="ancestor::s:StmtSimple/@StatementSubTreeCost" /></xsl:variable>\n    <div>Cost: <xsl:value-of select="format-number(number($EstimatedOperatorCost) div number($TotalCost), '0%')" /></div>\n  </xsl:template>\n\n  <!-- Dont show the node cost for statements. -->\n  <xsl:template match="s:StmtSimple" mode="NodeCostLabel" />\n\n  <!-- \n  ================================\n  Tool tip detail sections\n  ================================\n  The following section contains templates used for writing the detail sections at the bottom of the tool tip,\n  for example listing outputs, or information about the object to which an operator applies.\n  -->\n\n  <xsl:template match="*/s:Object" mode="ToolTipDetails">\n    <!-- TODO: Make sure this works all the time -->\n    <div class="qp-bold">Object</div>\n    <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:SetPredicate[s:ScalarOperator/@ScalarString]" mode="ToolTipDetails">\n    <div class="qp-bold">Predicate</div>\n    <div><xsl:value-of select="s:ScalarOperator/@ScalarString" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:OutputList[count(s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Output List</div>\n    <xsl:for-each select="s:ColumnReference">\n      <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <xsl:template match="s:NestedLoops/s:OuterReferences[count(s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Outer References</div>\n    <xsl:for-each select="s:ColumnReference">\n      <div><xsl:apply-templates select="." mode="ObjectName" /></div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <xsl:template match="@StatementText" mode="ToolTipDetails">\n    <div class="qp-bold">Statement</div>\n    <div><xsl:value-of select="." /></div>\n  </xsl:template>\n\n  <xsl:template match="s:Sort/s:OrderBy[count(s:OrderByColumn/s:ColumnReference) > 0]" mode="ToolTipDetails">\n    <div class="qp-bold">Order By</div>\n    <xsl:for-each select="s:OrderByColumn">\n      <div>\n        <xsl:apply-templates select="s:ColumnReference" mode="ObjectName" />\n        <xsl:choose>\n          <xsl:when test="@Ascending = 1"> Ascending</xsl:when>\n          <xsl:otherwise> Descending</xsl:otherwise>\n        </xsl:choose>\n      </div>\n    </xsl:for-each>\n  </xsl:template>\n\n  <!-- TODO: Seek Predicates -->\n\n  <!-- \n  ================================\n  Node icons\n  ================================\n  The following templates determine what icon should be shown for a given node\n  -->\n\n  <!-- Use the logical operation to determine the icon for the "Parallelism" operators. -->\n  <xsl:template match="s:RelOp[@PhysicalOp = 'Parallelism']" mode="NodeIcon" priority="1">\n    <xsl:element name="div">\n      <xsl:attribute name="class">qp-icon-<xsl:value-of select="translate(@LogicalOp, ' ', '')" /></xsl:attribute>\n    </xsl:element>\n  </xsl:template>\n\n  <!-- Use the physical operation to determine icon if it is present. -->\n  <xsl:template match="*[@PhysicalOp]" mode="NodeIcon">\n    <xsl:element name="div">\n      <xsl:attribute name="class">qp-icon-<xsl:value-of select="translate(@PhysicalOp, ' ', '')" /></xsl:attribute>\n    </xsl:element>\n  </xsl:template>\n  \n  <!-- Matches all statements. -->\n  <xsl:template match="s:StmtSimple" mode="NodeIcon">\n    <div class="qp-icon-Statement"></div>\n  </xsl:template>\n\n  <!-- Fallback template - show the Bitmap icon. -->\n  <xsl:template match="*" mode="NodeIcon">\n    <div class="qp-icon-Catchall"></div>\n  </xsl:template>\n\n  <!-- \n  ================================\n  Node labels\n  ================================\n  The following section contains templates used to determine the first (main) label for a node.\n  -->\n\n  <xsl:template match="s:RelOp" mode="NodeLabel">\n    <div><xsl:value-of select="@PhysicalOp" /></div>\n  </xsl:template>\n\n  <xsl:template match="s:StmtSimple" mode="NodeLabel">\n    <div><xsl:value-of select="@StatementType" /></div>\n  </xsl:template>\n\n  <!--\n  ================================\n  Node alternate labels\n  ================================\n  The following section contains templates used to determine the second label to be displayed for a node.\n  -->\n\n  <!-- Display the object for any node that has one -->\n  <xsl:template match="*[*/s:Object]" mode="NodeLabel2">\n    <xsl:variable name="ObjectName">\n      <xsl:apply-templates select="*/s:Object" mode="ObjectName">\n        <xsl:with-param name="ExcludeDatabaseName" select="true()" />\n      </xsl:apply-templates>\n    </xsl:variable>\n    <div>\n      <xsl:value-of select="substring($ObjectName, 0, 36)" />\n      <xsl:if test="string-length($ObjectName) >= 36">…</xsl:if>\n    </div>\n  </xsl:template>\n\n  <!-- Display the logical operation for any node where it is not the same as the physical operation. -->\n  <xsl:template match="s:RelOp[@LogicalOp != @PhysicalOp]" mode="NodeLabel2">\n    <div>(<xsl:value-of select="@LogicalOp" />)</div>\n  </xsl:template>\n\n  <!-- Disable the default template -->\n  <xsl:template match="*" mode="NodeLabel2" />\n\n  <!-- \n  ================================\n  Tool tip descriptions\n  ================================\n  The following section contains templates used for writing the description shown in the tool tip.\n  -->\n\n  <xsl:template match="*[@PhysicalOp = 'Table Insert']" mode="ToolTipDescription">Insert input rows into the table specified in Argument field.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Compute Scalar']" mode="ToolTipDescription">Compute new values from existing values in a row.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Sort']" mode="ToolTipDescription">Sort the input.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Clustered Index Scan']" mode="ToolTipDescription">Scanning a clustered index, entirely or only a range.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Stream Aggregate']" mode="ToolTipDescription">Compute summary values for groups of rows in a suitably sorted stream.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Hash Match']" mode="ToolTipDescription">Use each row from the top input to build a hash table, and each row from the bottom input to probe into the hash table, outputting all matching rows.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Bitmap']" mode="ToolTipDescription">Bitmap.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Clustered Index Seek']" mode="ToolTipDescription">Scanning a particular range of rows from a clustered index.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Index Seek']" mode="ToolTipDescription">Scan a particular range of rows from a nonclustered index.</xsl:template>\n\n  <xsl:template match="*[@PhysicalOp = 'Parallelism' and @LogicalOp='Repartition Streams']" mode="ToolTipDescription">Repartition Streams.</xsl:template>\n  <xsl:template match="*[@PhysicalOp = 'Parallelism']" mode="ToolTipDescription">An operation involving parallelism.</xsl:template>\n  \n  <xsl:template match="*[s:TableScan]" mode="ToolTipDescription">Scan rows from a table.</xsl:template>\n  <xsl:template match="*[s:NestedLoops]" mode="ToolTipDescription">For each row in the top (outer) input, scan the bottom (inner) input, and output matching rows.</xsl:template>\n  <xsl:template match="*[s:Top]" mode="ToolTipDescription">Select the first few rows based on a sort order.</xsl:template>\n\n  <!-- \n  ================================\n  Number handling\n  ================================\n  The following section contains templates used for handling numbers (scientific notation, rounding etc...)\n  -->\n\n  <!-- Outputs a number rounded to 7 decimal places - to be used for displaying all numbers.\n  This template accepts numbers in scientific notation. -->\n  <xsl:template name="round">\n    <xsl:param name="value" select="0" />\n    <xsl:variable name="number">\n      <xsl:call-template name="convertSciToNumString">\n        <xsl:with-param name="inputVal" select="$value" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:value-of select="round(number($number) * 10000000) div 10000000" />\n  </xsl:template>\n  \n  <!-- Template for handling of scientific numbers\n  See: http://www.orm-designer.com/article/xslt-convert-scientific-notation-to-decimal-number -->\n  <xsl:variable name="max-exp">\n    <xsl:value-of select="'0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'" />\n  </xsl:variable>\n\n  <xsl:template name="convertSciToNumString">\n    <xsl:param name="inputVal" select="0" />\n\n    <xsl:variable name="numInput">\n      <xsl:value-of select="translate(string($inputVal),'e','E')" />\n    </xsl:variable>\n\n    <xsl:choose>\n      <xsl:when test="number($numInput) = $numInput">\n        <xsl:value-of select="$numInput" />\n      </xsl:when> \n      <xsl:otherwise>\n        <!-- ==== Mantisa ==== -->\n        <xsl:variable name="numMantisa">\n          <xsl:value-of select="number(substring-before($numInput,'E'))" />\n        </xsl:variable>\n\n        <!-- ==== Exponent ==== -->\n        <xsl:variable name="numExponent">\n          <xsl:choose>\n            <xsl:when test="contains($numInput,'E+')">\n              <xsl:value-of select="substring-after($numInput,'E+')" />\n            </xsl:when>\n            <xsl:otherwise>\n              <xsl:value-of select="substring-after($numInput,'E')" />\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n\n        <!-- ==== Coefficient ==== -->\n        <xsl:variable name="numCoefficient">\n          <xsl:choose>\n            <xsl:when test="$numExponent > 0">\n              <xsl:text>1</xsl:text>\n              <xsl:value-of select="substring($max-exp, 1, number($numExponent))" />\n            </xsl:when>\n            <xsl:when test="$numExponent &lt; 0">\n              <xsl:text>0.</xsl:text>\n              <xsl:value-of select="substring($max-exp, 1, -number($numExponent)-1)" />\n              <xsl:text>1</xsl:text>\n            </xsl:when>\n            <xsl:otherwise>1</xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n        <xsl:value-of select="number($numCoefficient) * number($numMantisa)" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n</xsl:stylesheet>\n	host	//*[@StatementType="COMMIT TRANSACTION"]	0	SELECT schema_name FROM (SELECT name as [schema_name] FROM master..sysdatabases) tmp
10	PostgreSQL 8.3	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.procpid)                                     FROM pg_stat_activity                                                                                                                             WHERE upper(pg_stat_activity.datname) = 'DB_#databaseName#';                                                                                            DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;	\N	\N	\N	10/f9585/1	explain 	\N	\N	host	\N	0	select schema_name from (select datname as schema_name from pg_database) t
16	PostgreSQL 9.6	PostgreSQL	\n\nCREATE USER user_#databaseName# PASSWORD '#databaseName#';\nCREATE DATABASE db_#databaseName# OWNER user_#databaseName# ENCODING 'UTF8' TEMPLATE db_template;\ncommit;\nALTER USER user_#databaseName# SET statement_timeout = 30000;\nSELECT dblink_connect('#databaseName#', 'dbname=db_#databaseName# hostaddr=127.0.0.1 user=postgres');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE deferred_check (id INT PRIMARY KEY)');\nSELECT dblink_exec('#databaseName#', 'INSERT INTO deferred_check VALUES (1)');\nSELECT dblink_exec('#databaseName#', 'CREATE TABLE db_#databaseName#.public.deferred_#databaseName# (fk INT NOT NULL)');\nSELECT dblink_exec('#databaseName#', 'ALTER TABLE ONLY deferred_#databaseName# ADD CONSTRAINT deferred_#databaseName#_ref FOREIGN KEY (fk) REFERENCES deferred_check(id) DEFERRABLE INITIALLY DEFERRED');\nSELECT dblink_exec('#databaseName#', 'GRANT INSERT ON deferred_#databaseName# TO user_#databaseName#');\nSELECT dblink_disconnect('#databaseName#');\n\n	org.postgresql.Driver	SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE upper(pg_stat_activity.datname) = upper('DB_#databaseName#'); DROP DATABASE db_#databaseName#;DROP USER user_#databaseName#;	\N	\N	\N	16/69b4b/1	explain 	\N	\N	host	\N	1	select schema_name from (select datname as schema_name from pg_database) t
\.


--
-- Name: db_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('db_types_id_seq', 17, true);


--
-- Data for Name: schema_defs; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY schema_defs (id, db_type_id, short_code, last_used, ddl, current_host_id, md5, statement_separator, owner_id, structure_json, deprovision) FROM stdin;
1589300	9	dcb16	2014-05-11 05:15:24.462	\n\nCREATE TABLE ForgeRock\n\t(`id` int, `productName` varchar(7), `description` varchar(55))\n;\n\t\nINSERT INTO ForgeRock\n\t(`id`, `productName`, `description`)\nVALUES\n\t(1, 'OpenIDM', 'Platform for building enterprise provisioning solutions'),\n\t(2, 'OpenAM', 'Full-featured access management'),\n\t(3, 'OpenDJ', 'Robust LDAP server for Java')\n;\n	\N	dcb16f2d44703cf35623e5c8650f070e	;	\N	[{"columns":[{"type":"INT(10)","name":"id"},{"type":"VARCHAR(7)","name":"productName"},{"type":"VARCHAR(55)","name":"description"}],"table_type":"TABLE","table_name":"forgerock"}]	1
1589302	7	44b90	2014-05-11 05:28:27.178	-- this version is using your browser's built-in SQLite\nCREATE TABLE supportContacts\n\t(\n     id integer primary key, \n     type varchar(20), \n     details varchar(30)\n    );\n\nINSERT INTO supportContacts\n(id, type, details)\nVALUES\n(1, 'Email', 'admin@sqlfiddle.com');\n\nINSERT INTO supportContacts\n(id, type, details)\nVALUES\n(2, 'Twitter', '@sqlfiddle');	\N	44b900020923ae6d1b517286d9440347	;	\N	\N	1
1589303	5	b5362	2014-05-11 05:30:43.667	CREATE TABLE supportContacts \n\t(\n     id integer primary key, \n     type varchar(20), \n     details varchar(30)\n    );\n\nINSERT INTO supportContacts\n(id, type, details)\nVALUES\n(1, 'Email', 'admin@sqlfiddle.com');\n\nINSERT INTO supportContacts\n(id, type, details)\nVALUES\n(2, 'Twitter', '@sqlfiddle');	\N	b5362d09c5119808a6c7409fd00a64b7	;	\N	\N	1
1589338	4	c0be1	2014-12-07 21:32:48.736	-- table for our logging\ncreate table log_table\n( message varchar2(200)\n)\n//\n\n-- create package spec\ncreate or replace package pkg_test\nis\n    -- define one public procedure\n    procedure do;\nend;\n//\n\n-- create package body\ncreate or replace package body pkg_test\nis\n    -- private log procedure\n    procedure log(p_message in varchar)\n    is\n    begin\n        insert into log_table(message) values (p_message);\n    end;\n\n    -- private function to return twice the input\n    function double(p_number in number)\n    return number\n    is\n    begin\n        return 2 * p_number;\n    end;\n\n    -- public procedure that does. :)\n    procedure do\n    is\n    begin\n        log('2 * 12 = ' || double(12));\n    end;\n\nend;\n//	\N	c0be1c42165643ccdd365afbd01e3cf0	//	\N	[{"columns":[{"type":"VARCHAR2(200)","name":"MESSAGE"}],"table_type":"TABLE","table_name":"LOG_TABLE"}]	1
1589339	6	a7540	2014-12-07 21:53:17.243	\n\nCREATE TABLE ForgeRock\n    ([productName] varchar(13), [description] varchar(57))\n;\n    \nINSERT INTO ForgeRock\n    ([productName], [description])\nVALUES\n    ('OpenIDM', 'Platform for building enterprise provisioning solutions'),\n    ('OpenAM', 'Full-featured access management'),\n    ('OpenDJ', 'Robust LDAP server for Java')\n;\n	\N	a7540325c43a47db91002a51023b5ec2	;	\N	[{"columns":[{"type":"varchar(13)","name":"productName"},{"type":"varchar(57)","name":"description"}],"table_type":"TABLE","table_name":"ForgeRock"}]	1
1589340	2	dcb16	2014-05-11 05:15:24.462	\n\nCREATE TABLE ForgeRock\n\t(`id` int, `productName` varchar(7), `description` varchar(55))\n;\n\t\nINSERT INTO ForgeRock\n\t(`id`, `productName`, `description`)\nVALUES\n\t(1, 'OpenIDM', 'Platform for building enterprise provisioning solutions'),\n\t(2, 'OpenAM', 'Full-featured access management'),\n\t(3, 'OpenDJ', 'Robust LDAP server for Java')\n;\n	\N	dcb16f2d44703cf35623e5c8650f070e	;	\N	[{"columns":[{"type":"INT(10)","name":"id"},{"type":"VARCHAR(7)","name":"productName"},{"type":"VARCHAR(55)","name":"description"}],"table_type":"TABLE","table_name":"forgerock"}]	1
1589301	15	35773	2014-05-11 05:24:44.982	create table jsonData (\n    id serial primary key,\n    data json\n);\n\ninsert into jsonData (data) values (\n'{\n  "a": 1,\n  "b": 2,\n  "c": ["dog","cat","mouse"],\n  "d": {\n    "x": true\n  }\n }\n'::json),\n(\n'{\n  "a": 20,\n  "b": 40,\n  "c": ["fish","cat","rat","hamster"],\n  "d": {\n    "x": false\n  }\n }\n'::json);	\N	357738cadc59cd69eeb683e8e0f8fd8d	;	\N	[{"columns":[{"type":"serial(10)","name":"id"},{"type":"json(2147483647)","name":"data"}],"table_type":"TABLE","table_name":"jsondata"}]	1
1589342	16	69b4b	2017-06-16 02:32:16.105804	create table jsonData (\n    id serial primary key,\n    data jsonb\n);\n\ninsert into jsonData (data) values (\n'{\n  "a": 1,\n  "b": 2,\n  "c": ["dog","cat","mouse"],\n  "d": {\n    "x": true\n  }\n }\n'::json),\n(\n'{\n  "a": 20,\n  "b": 40,\n  "c": ["fish","cat","rat","hamster"],\n  "d": {\n    "x": false\n  }\n }\n'::json);	\N	69b4bf28985c2697362832f739bbfc0d	;	\N	\N	1
\.


--
-- Name: schema_defs_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('schema_defs_id_seq', 1589342, true);

--
-- Data for Name: queries; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY queries (schema_def_id, sql, md5, id, statement_separator, author_id) FROM stdin;
1589300	-- visit ForgeRock.com for details on the Open Identity Stack\n-- sqlfiddle.com is built with OpenIDM\n\nSELECT\n  productName,\n  description\nFROM\n  ForgeRock	486c85215008690438a43ad3fab9b0f7	1	;	\N
1589301	SELECT\n  json_extract_path_text(data, 'b') as b,\n  json_array_length(data->'c') as numAnimals\nFROM \n  jsonData\nWHERE\n  json_extract_path_text(data->'d', 'x') = 'true'\n	afe7d9b310445307acdfadba54e5c4dd	1	;	\N
1589302	select * from supportContacts\norder by id desc	7f9a9b537f2a77076a5be8b98c5d1ae3	1	;	\N
1589303	select * from supportContacts\norder by id desc	7f9a9b537f2a77076a5be8b98c5d1ae3	1	;	\N
1589338	-- execute the public procedure of the package\nbegin\n    pkg_test.do;\nend;\n//\n\n-- dbms_output doesn't work, so we log into a table \n-- (just like in real life) and select all records from it here\nselect *\nfrom   log_table\n//	3c3c7a6bd5bd0d4007f2597361943d54	1	//	\N
1589339	-- visit ForgeRock.com for details on the Open Identity Stack\n-- sqlfiddle.com is built with OpenIDM\n\nSELECT\n  productName,\n  description\nFROM\n  ForgeRock	486c85215008690438a43ad3fab9b0f7	1	;	\N
1589340	-- visit ForgeRock.com for details on the Open Identity Stack\n-- sqlfiddle.com is built with OpenIDM\n\nSELECT\n  productName,\n  description\nFROM\n  ForgeRock	486c85215008690438a43ad3fab9b0f7	1	;	\N
1589342	SELECT\n  jsonb_extract_path_text(data, 'b') as b,\n  jsonb_array_length(data->'c') as numAnimals\nFROM \n  jsonData\nWHERE\n  jsonb_extract_path_text(data->'d', 'x') = 'true'\n	913643e9a39f17df60d6b1d94cabc3bc	1	;	\N
\.


--
-- Data for Name: query_sets; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY query_sets (id, query_id, schema_def_id, row_count, execution_time, succeeded, sql, execution_plan, error_message, columns_list) FROM stdin;
\.


--
-- PostgreSQL database dump complete
--
